---
layout: post 
title: '"Мягкое" подавление немаксимумов' 
date: 2017-04-23
category: Computer vision
tags: [CV, CNN, object detection]
use_math: true
---

При детектировании, классически используется связка из двух подходов *сдвигающегося окна* (*sliding window*) и *подавления немаксимумов* (
*non-maximum suppression*). Последнее время, большое распространения для решения задачи детектирования получили свёрточные нейронные сети, в которых 
сдвигающееся окно не применяется, но и при использовании CNN на определенном этапе работы алгоритма возникает необходимость в подавление немаксимумов,
поскольку обычно генерируется достаточно большое количество дублей для каждого объекта на снимке. В рассматриваемой статье [1] как раз и предлагается
усовершенствование алгоритма подавления немаксимумов.

<!--more-->

Итак, в стандартной схеме детектирования объектов, вначале мы проходим детектором по изображению (или по пирамиде изображения в разных масштабах),
сдвигая окно детектирования, и получаем набор прямоугольников - предварительных претендентов. Для каждого прямоугольника мы кроме координат имеем 
приписанный "коэффициент уверенности". Т.е. имеем два набора:

1. набор прямоугольников $\mathbb {B} = \\{b_1, ... , b_N\\}$.

2. набор соответствующих этим прямоугольникам оценок $\mathbb {S}=\\{s_1, ... , s_N \\}$. 

Теперь создадим результирующий список $\mathbb {D}$ детектированных объектов и будем переносить в него прямоугольники из $\mathbb B$. Выбираем в цикле
прямоугольник $b_i \in \mathbb B$ с максимальной оценкой уверености $i = {\rm argmax} \\{S\\}$ и переносим его в список $\mathbb {D}$ (удаляя из
списка $\mathbb {B}$). При этом, в классической схеме подавления немаксимумов, мы также удаляем из списка $\mathbb {B}$ все прямоугольники 
пересекающиеся с $b_i$-ым больше чем на $T$. 

Понятно, что если мы уменьшаем $T$, то шанс отбросить не дубль уже задетектированного объекта, а другой объект, частично перекрывающийся текущим,
увеличивается. С другой стороны, если мы увеличиваем $T$, то повышается вероятность получить несколько прямоугольников для одного объекта на 
изображении. Для иллюстрации проблемы авторы приводят вот такую картинку:

![Перекрытие объектов детектирования]({{ site.baseurl }}/images/2017-04/soft_nms.jpg)

Дальняя лошадь, при применении классического подавления немаксимумов, даже при достаточно высоком пороге $T$ в результат детектирования не попадет.

Проблема понятна и авторы статьи [1] предлагают путь ее решения. Вначале они в классическом алгоритме заменяют "выкидывание" прямоугольников, 
пересекающихся с текущим, на зануление оценки этих прямоугольников. Т.е. выбрав прямоугольник $b \in \mathbb B$ с максимальной оценкой, они для всех
прямоугольников оставшихся в $\mathbb B$ заменяют оценку на:

$$
s_i = 
\begin{cases}
  s_i, & {\rm iou}(b, b_i) < T \\
  0,   & {\rm iou}(b, b_i) \geq T
\end{cases}
$$

Здесь ${\rm iou}(A, B)$ есть *intersection over union*, т.е. отношение площади пересечения прямоугольников $A$ и $B$ к площади их объединения.
Такая замена не меняет классический алгоритм, результаты его работы остаются прежними, однако, она позволяет его обобщить. А именно
ввести некоторую функцию $f({\rm iou}(b, b_i), s_i)$, описывающаю изменение оценки. Теперь перенося прямоугольник $b$ в список $\mathbb D$, для 
оставшихся мы заменяем оценку на:  

$$s_i = f({\rm iou}(b, b_i), s_i)$$

Свойства, которыми должна обладать функция $f$ понятны. Во-первых, она должна возвращать $s_i$ для прямоугольников не пересекающихся с $b$. Во-вторых,
она должна уменьшать оценку с ростом значения ${\rm iou}(b, b_i)$. В качестве простого примера такой функции можно взять, например,

$$
s_i =
\begin{cases}
  s_i, & {\rm iou}(b, b_i) < T \\
  s_i\cdot(1 - {\rm iou}(b, b_i))  & {\rm iou}(b, b_i) \geq T
\end{cases}
$$

Т.е. если пересечение меньше порога, то мы, как и в классическом алгоритме, не меняем оценку прямоугольника, если же пересечение больше порога, то
оценка уменьшается линейно от величины пересечения. Однако, это функция плоха тем, что она не является непрерывной. Поэтому в конечном итоге, авторы
предлагают следующий вариант:

$$s_i = s_i \cdot \exp\left(-\frac { {\rm iou}(b, b_i)^2} \sigma \right)$$

Данная функция удовлетворяет всем требованиям и плюс к тому, непрерывная и даже гладкая. Собственно, во второй половине статьи [1] описаны
эксперименты, которые авторы проделывают используя именно этот вариант функции $f$.

### Эксперименты

В статье представлены для сравнения результаты работы классического NMS алгоритма и предложенного soft-NMS алгоритма, для разных значений порога 
$T$ и параметра $\sigma$ соотвественно. Из сравнения следует, что предложенное изменение добавляет порядка 2% качества (в определенных ситуациях). С
результатами лучше ознакомится перед применением нового подхода, чтобы понять когда он работает лучше классического. Авторы приводят достаточно
цифр, чтобы можно было оценить стоит ли изменения того, чтобы их использовать. 

---
 
### Литература

1. *Navaneeth Bodla, Bharat Singh, Rama Chellappa, Larry S. Davis, "Improving Object Detection With One Line of Code", 
[arXiv:1704.04503](https://arxiv.org/abs/1704.04503) 2017*

